import layout
import scipy.sparse.csgraph as csgraph
import scipy.spatial.distance as dist
import numpy as np

def reduce_stress_direct(X, d, w, eta):
    """takes a n-by-2 matrix X, nC2 vectors d and w, and a vector of step sizes eta
    and performs stochastic gradient descent using c++ bindings generated by SWIG"""
    layout.sgd_direct(X, d, w, eta)

def layout_scipy(S, weighted=False, t_max=15, mu_min=.1):
    """takes a scipy sparse matrix S with n vertices
    and returns a n-by-2 matrix of positions X with minimized stress"""

    n,_ = S.shape
    d, w = init_dw(S, weighted)
    eta = init_eta(w, t_max, mu_min)

    # initialize positions
    X = np.random.rand(n, 2)

    # perform SGD
    layout.sgd_direct(X, d, w, eta)
    return X

# calculate shortest paths and weights
def init_dw(S, weighted):
    n_components, labels = csgraph.connected_components(S)
    if n_components > 1:
        raise Exception("graph has more than one connected component")

    d = csgraph.shortest_path(S, directed=False, unweighted=not weighted)
    d = dist.squareform(d)
    w = 1/d**2
    return d, w

# prepare annealing schedule
def init_eta(w, t_max, mu_min):
    eta_max = 1/min(w)
    eta_min = mu_min/max(w)
    lambd = np.log(eta_min/eta_max) / (t_max-1)

    eta = np.arange(t_max)
    eta = eta_max * np.exp(lambd*eta)

    return eta

def layout_scipy_focus(S, f, weighted=False, t_max=15, mu_min=.1):
    """takes a scipy sparse matrix S with n vertices
    and returns a n-by-2 matrix of positions X with minimized stress
    and a focus on vertex f"""

    n,_ = S.shape
    if f < 0 or f >= n:
        raise Exception('focus has index not within bounds')

    d, w = init_dw(S, weighted)
    eta = init_eta(w, t_max, mu_min)

    # set relevant weights to effectively infinity for focus
    w_f = 1/min(eta)
    ij = 0
    for i in range(n):
        for j in range(i,n):
            if i==f or j==f:
                w[ij] = w_f
            ij += 1

    # w_f = 1/min(eta)
    # nC2_f = int((n*(n-1))/2 - ((n-f)*(n-f-1))/2) # squareform stuff
    # for j in range(n):
    #     if j != f:
    #         fj = nC2_f + (j-f-1)
    #         print(fj)
    #         w[fj] = w_f

    # initialize positions
    X = np.random.rand(n, 2)

    # perform SGD
    layout.sgd_direct(X, d, w, eta)
    return X

def layout_scipy_y_constrained(S, Y, weighted=False, t_max=15, mu_min=.1):
    """takes a scipy sparse matrix S with n vertices
    and returns a n-by-2 matrix of positions X with minimized stress
    with y-axis positions constrained to the values in Y"""

    n,_ = S.shape
    d, w = init_dw(S, weighted)
    eta = init_eta(w, t_max, mu_min)

    # initialize positions
    X = np.random.rand(n, 2)

    # constrain y axis positions
    for i in range(n):
        X[i,1] = Y[i];

    # perform SGD only on x-axis
    layout.sgd_direct_horizontal(X, d, w, eta)
    return X

